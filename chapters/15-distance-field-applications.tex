%\chapter{Distance Fields and its Applications}
%\section{Applications}

%\subsubsection{Conclusions}%In this section we introduced the very important displacement map- ping technique. More comparison can be find in 35, but unfortunately which didn’t include directional distance maps.






\chapter{Distance Field Ambient Occlusion}
Rendering worlds with two triangles with raytracing





http://www.csh.rit.edu/~gman/PersonalWebpage/ao.html




\chapter{Distance Field Specular Occlusion}

Crytek:
Note: Current implementation provides only diffuse GI, for specular we still need light probes. System may be used as AO add-on to light probes or may completely replace diffuse contribution of light probes.


\chapter{Reflections}
Another use case for ray tracing is reflections, which can be handled in a similar fashion to shadows. Instead of directing the ray towards a known light source, we send the ray in the direction calculated by performing the mathematical reflect function between the vector from the viewpoint and the normal vector at the surface. Ray traced reflections have several advantages over raster techniques like reflection maps.  Not only do they reflect dynamic objects without needing separate rendering passes, nearby objects and self-reflections are handled perfectly.






\chapter{Destruction Mask}

A decal is a relatively small piece of geometry that is overlaid on top of the reg- ular geometry in the scene, allowing the visual appearance of the surface to be modified dynamically. Examples include bullet holes, foot prints, scratches, cracks, etc.The approach most often used by modern engines is to model a decal as a rectangular area that is to be projected along a ray into the scene. This gives rise to a rectangular prism in 3D space. Whatever surface the prism intersects first becomes the surface of the decal. The triangles of the intersected geome- try are extracted and clipped against the four bounding planes of the decal’s projected prism. The resulting triangles are texture-mapped with a desired decal texture by generating appropriate texture coordinates for each vertex. These texture-mapped triangles are then rendered over the top of the regular scene, often using parallax mapping to give them the illusion of depth and with a slight z-bias (usually implemented by shifting the near plane slightly) so they don’t experience z-fighting with the geometry on which they are over- laid. The result is the appearance of a bullet hole, scratch or other kind of surface modification. Some bullet-hole decals are depicted in Figure 10.64.For more information on creating and rendering decals, see [7, Section 4.8] and [28, Section 9.2].




\chapter{Blending fields}
\chapter{Culling}
A compute shader is dispatched to handle all objects adds, removes and transforms for a frame, which are just operations on a buffer.


 Cullingofobjectstoview100xfasterthanCPU– 2 million tree instances in Kite demo -> 50k on screen @ .1ms on PS4Possible because all operations on objects down the pipeline are on the GPU
 
 
 No graphics API calls are used on objects, because no triangles are involved when ray marching the SDF. This allows the object management and culling to be done on the GPU(along with the rest of the technique)

\chapter{Morphology}

\chapter{Anti-aliasing}
Recently, it seems that there is general widespread agreement that distance fields provide the most suitable anti-aliased representation of geometric objects for the purposes of Volume Graphics. The term Volume Graphics was first introduced by Kaufman, Cohen and Yagel in 1993 [KCY93], where they presented the advantages of us- ing volumetric models. Although they were working with binary representations which suffered from aliasing, many of the methods they proposed and discussed have adapted well to distance fields. Volume Graphics is now a subject area in its own right, demonstrated by a biannual “Vol- ume Graphics” conference series which started at Swansea in 1999 [CKY00].


\chapter{Conclusion}


CPU Rendering