\chapter{Irradiance Caching}
http://www.ludicon.com/castano/blog/2014/07/irradiance-caching-continued/

%Several researchers have investigated how to reduce the noise by distributing rays more carefully and for example, by using bidirectional Monte Carlo ray tracing, in which rays are traced simultaneously from the light and the eye. However, these pure unbiased Monte Carlo-based ray tracing methods are still very time-consuming. An alternative is biased Monte Carlo ray tracing, in which other convergence properties are accepted. One example is irradiance caching which stores and re-uses indirect illumination on diffuse surfaces via an interpolation scheme.

%Caching in the context of GI means to compute results sparsely and interpolated in-between. Caching is mostly orthogonal to the particular GI method used and should be compatible to many of the before mentioned approaches. Pre- viously it was mainly used in combination with Monte Carlo ray tracing however (Sec. 3.2).
%
%Similar ideas are used in interactive GI, e. g., when combining screen space-illumination for nearby and other approaches for far fields [KD10,REH⇤11].
%
%As other schemes that use interpolation to reconstruct illumination from a sparse set of samples, the irradiance cache is a biased algorithm (see section 2.1.9).
%The irradiance cache, in its initial form, suffers from a number of problems:%• The range calculation for a sample involves a stochastic process, which may occasionally result in a density that is too sparse, leading to leaks and other artifacts.%• Adding samples on-the-fly may lead to new samples that would have affected the estimated radiance arriving at pixels that already have been finalized.%• In a multi-threaded environment, adding samples from several rendering threads simultaneously requires extensive synchronization.%• For dynamic light sources, the samples need to be recreated for each frame, leading to temporal noise.%Most of these have been addressed in more recent work. Krˇivánek et al. propose to use neighbor clamping to prevent leaks [141]. Progressive refinement or an irradiance gathering pass can be used to prevent samples from affecting already rendered pixels [142]. Several methods have been proposed to make the irradiance cache more suitable for a multi-threaded environment [232, 64]. In an off-line environment, temporal noise is solved by refining the irradiance cache until a predefined maximum error is guaranteed to be not exceeded. This illustrates an important design constraint of the irradiance cache: where necessary, it trades rendering time for image fidelity.

